<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="EnvDTE" #>
<#@ Assembly Name="EnvDTE80" #>
<#@ Assembly Name="VsLangProj" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ComponentModel" #>
<#@ import namespace="EnvDTE"#>
<#@ import namespace="EnvDTE80"#>
<#@ import namespace="VSLangProj"#>
<#@ Include File="./AutoGeneratedComment.ttinclude" #>
<#@ Include File="./EnvDteHelper.ttinclude" #>
<#
    // Go gather the code items of interest to this generator
    this.GatherCodeItems();

    // Generate each metadata type
    foreach (var namespaceItem in this.propertyNameCodeClassesByNamespace)
    {
#>
namespace <#=namespaceItem.Key#>.PropertyNames
{
<#
        foreach (OutputClassItem classItem in namespaceItem.Value)
        {
            var className = classItem.CodeClass.Name;
            var commentizedClassName = EnvDteHelper.CommentizeClassName(EnvDteHelper.GetClassName(classItem.CodeClass));
            var classVisibility = EnvDteHelper.VisibilityFromAccess(classItem.CodeClass.Access);
#>
    /// <summary>
    /// Contains property name constants for the properties in the
    /// <see cref="<#=namespaceItem.Key#>.<#=commentizedClassName#>"/> class.
    /// </summary>
    <#=classVisibility#> static partial class <#=className#>Metadata
    {
<#
            foreach (var codeProperty in classItem.Properties)
            {
                var propertyName = codeProperty.Name;
                var propertyNameValue = (propertyName[0] == '@') ? propertyName.Substring(1) : propertyName;
                var propertyVisibility = GetPropertyVisibility(codeProperty);
#>
        /// <summary>The name of the <see cref="<#=commentizedClassName#>.<#=propertyName#>"/> property.</summary>
        <#=propertyVisibility#> const string <#=propertyName#> = "<#=propertyNameValue#>";

<#          }#>
    }

<#      } #>
}

<#
    }
#>
<#+
    ProjectItem templateProjectItem;

    void GatherCodeItems()
    {
        var serviceProvider = (IServiceProvider)this.Host;
        var dte = (DTE)serviceProvider.GetService(typeof(DTE));
        this.templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

        Project project = this.templateProjectItem.ContainingProject;

        foreach (var projectItem in EnvDteHelper.GetProjectItems(project.ProjectItems, pi => pi != this.templateProjectItem))
            if (projectItem.FileCodeModel != null)
                foreach (var codeNamespace in EnvDteHelper.GetCodeNamespaces(projectItem.FileCodeModel.CodeElements))
                    foreach (var codeClass in EnvDteHelper.GetCodeClasses(codeNamespace.Members))
                        this.GatherInterestingClasses(codeClass);
    }

    void GatherInterestingClasses(CodeClass2 codeClass)
    {
        // Only process public and internal classes
        var access = codeClass.Access;
        if (access != vsCMAccess.vsCMAccessPublic && access != vsCMAccess.vsCMAccessProject)
            return;

        // Filter-out non-INotifyPropertyChanged classes
        if (!codeClass.IsDerivedFrom[typeof(INotifyPropertyChanged).FullName])
            return;

        // Filter the set of interesting properties
        var properties =
            from p in codeClass.Members.OfType<CodeProperty>()
            where IsPropertyInteresting(p)
            select p;

        // Add it to the output collections, if it has any interesting properties
        this.AddClass(codeClass, properties);
    }

    static bool IsPropertyInteresting(CodeProperty codeProperty)
    {
        var propertyName = codeProperty.Name;

        // Filter-out an empty string
        if (string.IsNullOrWhiteSpace(propertyName))
            return false;

        // Filter-out keywords
        if (EnvDteHelper.IsCSharpKeyword(propertyName))
            return false;

        // Allow escaped keywords
        if (propertyName[0] != '@' || !EnvDteHelper.IsCSharpKeyword(propertyName.Substring(1)))
        {
            // Filter-out property name with invalid identifer characters
            // Particularly, this filters-out explicitly declared interface properties (which have a period)
            if (!EnvDteHelper.IsValidIdentifier(propertyName))
                return false;
        }

        // The property is interesting
        return true;
    }

    static string GetPropertyVisibility(CodeProperty codeProperty)
    {
        switch (codeProperty.Access)
        {
            case vsCMAccess.vsCMAccessPrivate:
            case vsCMAccess.vsCMAccessProject:
                return "internal";
            default:
                return "public";
        }
    }

    private SortedDictionary<string, List<OutputClassItem>> propertyNameCodeClassesByNamespace =
        new SortedDictionary<string, List<OutputClassItem>>();

    void AddClass(CodeClass2 codeClass, IEnumerable<CodeProperty> properties)
    {
        // If it has any interesting properties, add it to the collection of items to output
        if (properties.FirstOrDefault() != null)
        {
            var namespaceFullName = codeClass.Namespace.FullName;

            List<OutputClassItem> list;
            if (!this.propertyNameCodeClassesByNamespace.TryGetValue(namespaceFullName, out list))
            {
                list = new List<OutputClassItem>();
                this.propertyNameCodeClassesByNamespace.Add(namespaceFullName, list);
            }

            var classItem = new OutputClassItem(codeClass, properties);
            list.Add(classItem);
        }
    }

    class OutputClassItem
    {
        public OutputClassItem(CodeClass2 codeClass, IEnumerable<CodeProperty> properties)
        {
            this.CodeClass = codeClass;
            this.Properties = new List<CodeProperty>(properties);
        }

        public CodeClass2 CodeClass { get; private set; }

        public List<CodeProperty> Properties { get; private set; }
    }
#>